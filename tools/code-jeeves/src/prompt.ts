import { askOpenApiStructured2 } from "./askOpenAI";
import { FunctionResponseSchema, TaskSchema } from "./types/taskFileSchema";
import { ChatRequestMessage } from "llm-api";
import { createAdaptableCircuitBreaker } from "./circuit-breaker";
import {
  checkCodeForFunctionsAndExports,
  checkForUnspecifiedTypes,
  checkTypescriptSyntax,
  extractFunctionName,
} from "./typescriptTypecheckUtils";

/******************************** */
type SupportedLang = "ts" | "py";
type LangConfig = {

  /**
   * if defined it these checks will be run on the source code generated by the LLM. 
   */
  sourceCodeChecksHandler?: ChecksFunction;

   /**
   * if defined it these checks will be run on the test code generated by the LLM. 
   */
   testCodeChecksHandler?: ChecksFunction;

   /**
   * a command that will be used to run the generated test.
   */
  testCommand?: `${string} {filename}`;
  
};

type ChecksFunction = (data: FunctionResponseSchema) => void;
type LanguageConfigRecord = Partial<Record<SupportedLang, LangConfig>>;

/******************************** */

const entry: TaskSchema = {
  id: "getCharacterByName",
  task: "create a function that 'queries the star wars api and returns a character by name'.",
  ext: "ts",
  declaration:
    "async function getCharacterByName(name:String):Promise<StarWarsCharacterDetails>",
  preferences: "use fetch",
};

const checks: LanguageConfigRecord = {
  ts: {
    sourceCodeChecksHandler: runImplementationTypescriptChecks,
    testCodeChecksHandler:runTestTypescriptChecks,
    testCommand: "bun test {filename}",
  },
};

const languageConfig = entry.ext
  ? checks[entry.ext as SupportedLang]
  : undefined;

createImplementationSourceCodeFromTask(
  entry,
  languageConfig,
)
  .then((response) => {
    console.log("Success:");
    console.log(JSON.stringify(response, null, "  "));
  })
  .catch((error) => console.error("Failed:", error));

/******************************** */

export 
function runImplementationTypescriptChecks(data: FunctionResponseSchema) {
  /**
   * @deprecated since 24/2, might be no longer necessary because we fixed the bugs in the validation step that irritated gpt.
   */
  const constraints =
    "You MUST return the previous source code with the error fixed. Don't abbreviate. Don't rename variables or types without a reason.";

  checkTypescriptSyntax(data.sourceCode);

  if (data.sourceCode.trim() == "")
    throw new Error("'sourceCode' may not be empty");

  const name = extractFunctionName(data.sourceCode);
  console.log("extracted function name:", name);
  if (entry.id != name) throw new Error("function must be named:" + entry.id);

  checkCodeForFunctionsAndExports(data.sourceCode);
  const unspecifiedTypes2 = checkForUnspecifiedTypes(data.sourceCode);
  if (unspecifiedTypes2.length)
    throw new Error(
      `'sourceCode' - missing type declaration for:'${unspecifiedTypes2.join(",")}' add it. ${constraints}`,
    );
}

export 
function runTestTypescriptChecks(data: FunctionResponseSchema) {
  /**
   * @deprecated since 24/2, might be no longer necessary because we fixed the bugs in the validation step that irritated gpt.
   */
  const constraints =
    "You MUST return the previous source code with the error fixed. Don't abbreviate. Don't rename variables or types without a reason.";

  checkTypescriptSyntax(data.sourceCode);

  if (data.sourceCode.trim() == "")
    throw new Error("'sourceCode' may not be empty");

 // todo validate import
 //  checkCodeForFunctionsAndExports(data.sourceCode);
  const unspecifiedTypes2 = checkForUnspecifiedTypes(data.sourceCode);
  if (unspecifiedTypes2.length)
    throw new Error(
      `'sourceCode' - missing type declaration for:'${unspecifiedTypes2.join(",")}' add it. ${constraints}`,
    );
}

export 
function createImplementationSourceCodeFromTask(
  entry: TaskSchema,
  langConfig?: LangConfig,
) {
  const systemMessage = `You are a 10x Software developer.
  You will be asked to create source code. 
  You will do so and think step by step.
  If you come upon unspecified types you infer them to the best of your knowledge.
  Afterwards you are give error messages directly related to the source code you generated.
  You will fix them.
  You don't rename variables or types without a reason.
  You are not lazy and write full source code.
  When in a longer conversation with the user, you will give full source code.
 `;

  const prompt = `${entry.task}
  Infer the language from the file extension: 'ts'.
  ${entry.preferences ? "You are being given the following preferences, use them if you can and if it makes sense in the scenario:'" + entry.preferences + "'" : ""}
  The interface of the function looks the following '${entry.declaration}'.
  The function must be exported if possible in the language.
  `;
  const initialParams = {
    history: [] as ChatRequestMessage[],
    prompt,
  };

  return createAdaptableCircuitBreaker<
    typeof initialParams,
    FunctionResponseSchema
  >({
    initialParams,
    retryParamsCallback: (params, lastResponse, error) => {
      params.history.push({ role: "user", content: params.prompt });

      // in case zod-gpt fails there is no response
      if (lastResponse) {
        params.history.push({
          role: "assistant",
          content: JSON.stringify(lastResponse.sourceCode),
        });
      }
      return {
        ...params,
        prompt: "There was an error in your previous response:" + error.message,
      };
    },
    fn: async (params, setLastResponse) => {
      const res = await askOpenApiStructured2(params.prompt, {
        schema: FunctionResponseSchema,
        messageHistory: [],
        systemMessage,
      });
      setLastResponse(res.data);

      langConfig?.sourceCodeChecksHandler?.(res.data);

      return res.data;
    },
  });
}

/******************************** */

export 
function createTestSourceCodeFromTask(entry: TaskSchema,langConfig?: LangConfig) {
  const systemMessage = `You are a 10x Software tester.
  You will be asked to create tests. 
  You will do so and think step by step.
  
  Afterwards you are give error messages directly related to the test code you generated.
  You will fix them.
  You don't rename variables or types without a reason.
  You are not lazy and write full source code.
  When in a longer conversation with the user, you will give full source code.
 `;

  const prompt = `${entry.task}
  Infer the language from the file extension: 'ts'.
  ${entry.preferences ? "You are being given the following preferences, use them if you can and if it makes sense in the scenario:'" + entry.preferences + "'" : ""}
  The interface of the function looks the following '${entry.declaration}'.
  The function must be imported. 
  The function can be found in the same folder as the test.
  The file that contains the function is named like the function itself.
  You MUST at least create one positive and one negative test case.

  For Typescript use "jest". 
  For python use "PyUnit"
  `;

  /**
   * @deprecated since 24/2, might be no longer necessary because we fixed the bugs in the validation step that irritated gpt.
   */
  const constraints =
    "You MUST return the previous source code with the error fixed. Don't abbreviate. Don't rename variables or types without a reason.";

  const initialParams = {
    history: [] as ChatRequestMessage[],
    prompt,
  };

  return createAdaptableCircuitBreaker<
    typeof initialParams,
    FunctionResponseSchema
  >({
    initialParams,
    retryParamsCallback: (params, lastResponse, error) => {
      params.history.push({ role: "user", content: params.prompt });

      // in case zod-gpt fails there is no response
      if (lastResponse) {
        params.history.push({
          role: "assistant",
          content: JSON.stringify(lastResponse.sourceCode),
        });
      }

      return {
        ...params,
        prompt: "There was an error in your previous response:" + error.message,
      };
    },
    fn: async (params, setLastResponse) => {
      const res = await askOpenApiStructured2(params.prompt, {
        schema: FunctionResponseSchema,
        messageHistory: [],
        systemMessage,
      });
      setLastResponse(res.data);

      langConfig?.testCodeChecksHandler?.(res.data);

      return res.data;
    },
  });
}
